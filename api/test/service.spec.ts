import axios from 'axios';
import { Username } from '../src/model';
import { retrieveGithubInformation, generateAiDescription, generateAiNickname } from '../src/service';
import Anthropic from '@anthropic-ai/sdk';

jest.mock('axios');
jest.mock('@/model', () => {
  return {
    Username: {
      findOne: jest.fn(),
      save: jest.fn(),
      find: jest.fn(),
    },
  };
});
jest.mock('@anthropic-ai/sdk', () => {
  return jest.fn().mockImplementation(() => ({
    messages: {
      create: jest.fn(),
    },
  }));
});

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

describe('Service Functions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('retrieveGithubInformation', () => {
    it('should retrieve GitHub information and calculate score correctly', async () => {
      const mockedAxiosGet = axios.get as jest.Mock;
      mockedAxiosGet.mockResolvedValueOnce({
        status: 200,
        data: {
          login: 'testuser',
          location: 'US',
          followers: 10,
          following: 5,
          repos_url: 'https://api.github.com/users/testuser/repos',
          events_url: 'https://api.github.com/users/testuser/events',
          bio: 'Test Bio',
          avatar_url: 'test-avatar-url',
          name: 'Test User',
          html_url: 'https://github.com/testuser',
          twitter_username: 'testtwitter',
        },
      });
      mockedAxiosGet.mockResolvedValueOnce({
        data: [
          { stargazers_count: 5, forks_count: 2, language: 'JavaScript' },
          { stargazers_count: 3, forks_count: 1, language: 'Python' },
        ],
      });
      mockedAxiosGet.mockResolvedValueOnce({
        data: [{ type: 'PushEvent' }, { type: 'PullRequestEvent' }, { type: 'IssuesEvent' }],
      });

      const result = await retrieveGithubInformation('testuser');

      expect(result).toEqual({
        score: expect.any(Number),
        country: 'US',
        favoriteLanguage: 'Python',
        contributions: expect.any(Number),
        status: 200,
        bio: 'Test Bio',
        avatar: 'test-avatar-url',
        name: 'Test User',
        followers: 10,
        following: 5,
        github_url: 'https://github.com/testuser',
        twitter_username: 'testtwitter',
      });
    });

    it('should return default values if GitHub user is not found (404)', async () => {
      const mockedAxiosGet = axios.get as jest.Mock;
      mockedAxiosGet.mockResolvedValueOnce({ status: 404 });

      const result = await retrieveGithubInformation('nonexistentuser');

      expect(result).toEqual({
        score: 0,
        country: 'Unknown',
        favoriteLanguage: 'Unknown',
        contributions: 0,
        status: 404,
        bio: '',
        avatar: '',
        name: '',
        followers: 0,
        following: 0,
        github_url: '',
        twitter_username: '',
      });
    });
  });

  describe('generateAiDescription', () => {
    it('should generate a description using the AI service', async () => {
      const user = {
        username: 'testuser',
        score: 1500,
        location: 'US',
        fav_language: 'JavaScript',
        bio: 'Developer',
        followers: 10,
        ai_description: 'A passionate coder',
      } as Username;

      (anthropic.messages.create as jest.Mock).mockResolvedValueOnce({
        content: [{ text: 'Test description generated by AI' }],
      });

      const result = await generateAiDescription(user);
      expect(result).toBe("That user has such a bad profile that we couldn't generate a description for them. ðŸ’©");
    });

    it('should return a fallback message if AI service fails to generate description', async () => {
      const user = {
        username: 'testuser',
        score: 500,
        location: 'Unknown',
        fav_language: 'Unknown',
        bio: 'Unknown',
        followers: 0,
      } as Username;

      (anthropic.messages.create as jest.Mock).mockResolvedValueOnce({
        content: [],
      });

      const result = await generateAiDescription(user);
      expect(result).toBe("That user has such a bad profile that we couldn't generate a description for them. ðŸ’©");
    });
  });

  describe('generateAiNickname', () => {
    it('should generate a nickname using the AI service', async () => {
      const saveMock = jest.fn().mockResolvedValueOnce(undefined);
      const user = {
        username: 'testuser',
        name: 'Test User',
        ai_nickname: 'The Code Master ðŸ’»',
        ai_description: 'A passionate coder',
        save: saveMock,
      } as unknown as Username;

      (anthropic.messages.create as jest.Mock).mockResolvedValueOnce({
        content: [{ text: 'The Code Master ðŸ’»' }],
      });

      const result = await generateAiNickname(user);
      expect(result).toBe('The Code Master ðŸ’»');
    });

    it('should return the existing AI nickname if it already exists', async () => {
      const user = {
        ai_nickname: 'Code Wizard',
      } as Username;

      const result = await generateAiNickname(user);
      expect(result).toBe('Code Wizard');
    });
  });
});
